#!/usr/bin/env perl
use strict;
use warnings;
use Cwd;
use File::Spec;
use System::Command;
use Git::Repository;
use Test::Git;
use Getopt::Long;
use Encode;
use utf8;

# command-line options
my %option = ( bundle => 'test.bundle' );
GetOptions( \%option, 'verbose', 'gitk', 'bundle=s', 'force' )
    or die "Usage: $0 [ --verbose ] [ --gitk ]\n";

$option{bundle} = File::Spec->rel2abs( $option{bundle} );

# check if we have a recent enough git
my $version = Git::Repository->version;
die "git version 1.7.8 need for commit -S, this is only $version\n"
    if Git::Repository->version_lt( '1.7.8' );

# check if gpg is available
my $gpg = eval { System::Command->new(qw( gpg --version ))->stdout->getline }
    or die "gpg not found in the path\n";

# setup our local GnuPG environment
$ENV{GNUPGHOME} = File::Spec->catfile( getcwd(), 'gnupg' );
my $keyid = '7621C403';

# setup a test repository
my $r = test_repository( git => { quiet => 1 } );

# some settings
$r->run( config => qw( i18n.commitencoding utf-8 ) );
$ENV{GIT_AUTHOR_DATE} = my $tick = time - 3600;
$ENV{GIT_COMMITTER_DATE} = time;
$ENV{GIT_AUTHOR_NAME}    = $ENV{GIT_COMMITTER_NAME} = 'Example Author';
$ENV{GIT_AUTHOR_EMAIL}   = $ENV{GIT_COMMITTER_EMAIL} = 'author@example.com';

### helper subs

# put content in a file, with an optional encoding
my $file = File::Spec->catfile( $r->work_tree => 'file.txt' );
sub update_file {
    my ( $content, $encoding ) = @_;
    $encoding ||= 'UTF-8';
    open my $fh, ">:encoding($encoding)", $file or die "Can't open $file: $!";
    print {$fh} $content;
    close $fh;
    $r->run( add => $file );
}

# do the bookkeeping around the commit/tag creation
my %seen;
sub commit {
    my %arg = @_;

    # update the file if needed
    if ( $arg{content} ) {
        update_file( $arg{content}, $arg{content_encoding} );
    }

    # click a tick
    $tick++;
    $ENV{GIT_AUTHOR_DATE} = $tick;

    # execute the coderef
    $r->run( config => 'i18n.commitencoding', $arg{commit_encoding} )
        if $arg{commit_encoding};
    $arg{code}->();
    $r->run( config => qw( --unset i18n.commitencoding iso-8859-1 ) )
        if $arg{commit_encoding};

    # record the description
    my $head = $r->run( log => -1 => '--pretty=format:%H' );
    return if exists $seen{$head};
    $seen{$head} = $arg{comment};

    # show the raw commit for --verbose
    return if !$option{verbose};
    print "---- $head ", '-' x 32, "\n";
    print "$_\n" for $r->run( qw( cat-file commit ), $head );
    print "\n";
}

### main program

commit(
    comment => 'empty tree',
    code    => sub {
        my $tree = $r->run( mktree => { input => '' } );
        my $head = $r->run( 'commit-tree', $tree, -m => 'empty tree' );
        $r->run( 'update-ref', 'refs/heads/master' => $head );
    }
);

commit(
    comment => 'basic commit',
    content => "Hello\n",
    code    => sub {
        $r->run( commit => -m => 'hello (en)' );
    }
);

# make an encoding branch
$r->run( branch => 'encoding' );

commit(
    comment => 'utf-8 content, utf-8 message',
    content => "こんにちは\n",
    code    => sub { $r->run( commit => -am => 'こんにちは (ja)' ); },
);

commit(
    comment => 'gpgsig',
    content => "hej\n",
    code    => sub {
        $r->run( commit => "-S$keyid" => -m => 'hej (da)' );
    }
);

# now work in the encoding branch
$r->run( checkout => 'encoding' );
commit(
    comment          => 'shift-jis content, shift-jis message',
    content          => "こんにちは\n",
    content_encoding => 'shift-jis',
    commit_encoding  => 'shift-jis',
    code             => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'shift-jis', 'こんにちは (ja)' );
        $cmd->close;
    }
);

commit(
    comment         => 'utf-8 content, isi-8859-1 message',
    content         => "halló\n",                            # utf-8
    commit_encoding => 'iso-8859-1',
    code            => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'halló (is)' );
        $cmd->close;
    }
);

commit(    # actually, a tag
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.0' );
    }
);

commit(
    comment         => 'utf-8 content, iso-8859-1 message',
    content         => "góður dagur\n",                     # utf-8
    commit_encoding => 'iso-8859-1',
    code            => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'góður dagur (is)' );
        $cmd->close;
    }
);

commit(                                                       # a tag
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.1' );
    }
);

commit(
    comment          => 'utf-8 content, iso-8859-1 message, gpgsig',
    content          => 'olá',
    content_encoding => 'iso-8859-1',
    commit_encoding  => 'iso-8859-1',
    code             => sub {
        my $cmd = $r->command( commit => '-aF-' => "-S$keyid" );
        print { $cmd->stdin } encode( 'iso-8859-1', 'olá (pt)' );
        $cmd->close;
    }
);

# signed tag
commit(    # no commit
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.2' );
    }
);

# some basic commit
commit(
    comment => 'basic commit',
    content => "bonjour\n",
    code    => sub {
        $r->run( commit => -m => 'bonjour (fr)' );
    }
);

# signed tag
commit(    # no commit
    comment => 'gpgsig',
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.3' );
    }
);

# mergetag
$r->run( checkout => 'master' );
commit(
    comment => 'mergetag',
    code    => sub { $r->run( merge => -s => 'ours', 'v1.0.0' ); }
);

# mergetag + encoding
commit(
    comment         => 'iso-8859-1 message, mergetag',
    commit_encoding => 'iso-8859-1',
    code            => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.1' );
        my $cmd = $r->command( commit => '-F-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'dobrý den (cs)' );
        $cmd->close;
    }
);

# mergetag + gpgsig
commit(
    comment => 'gpgsig, mergetag',
    code    => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.2' );
        $r->run( commit => -am => 'bom dia', "-S$keyid" );
    }
);

# mergetag + gpgsig + encoding
commit(
    comment         => 'iso-8859-1 message, gpgsig, mergetag',
    commit_encoding => 'iso-8859-1',
    code            => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.3' );
        my $cmd = $r->command( commit => '-aF-' => "-S$keyid" );
        print { $cmd->stdin } encode( 'iso-8859-1', 'buen día (es)' );
        $cmd->close;
    }
);

### final steps

# README
{
    my @readme = $r->run( log => qw( --graph --pretty=oneline --decorate ) );
    open my $fh, '>', File::Spec->catfile( $r->work_tree, 'README' );
    print {$fh} << 'README';
git-test-repository
===================

This repository contains all the "special cases" of objects that I know of.

Here's an ascii-art view of the annotated commit graph,
with the details related to each commit:

README
    print $fh "    $_\n"
        for map { s/ (([a-f0-9]{40})(?: \([^)]+\))?) .*/$1 $seen{$2}/g; $_ }
        @readme;
    close $fh;
    $r->run( add => 'README' );
    $r->run( commit => -am => 'add a README' );
}

# gitk
if( $option{gitk} ) {
    my $home = getcwd();
    chdir $r->work_tree;
    `gitk --all --date-order`;
    chdir $home;
}

# bundle
if( !-e $option{bundle} || $option{force} ) {
    $r->run( bundle => create => $option{bundle} => '--all' );
}
