#!/usr/bin/env perl
use strict;
use warnings;
use Cwd;
use File::Spec;
use System::Command;
use Git::Repository;
use Test::Git;
use Getopt::Long;
use Encode;
use utf8;

# command-line options
my %option = ( bundle => 'test.bundle' );
GetOptions( \%option, 'verbose', 'gitk', 'bundle=s', 'force' )
    or die "Usage: $0 [ --verbose ] [ --gitk ]\n";

$option{bundle} = File::Spec->rel2abs( $option{bundle} );

# check if we have a recent enough git
my $version = Git::Repository->version;
die "git version 1.7.8 need for commit -S, this is only $version\n"
    if Git::Repository->version_lt( '1.7.8' );

# check if gpg is available
my $gpg = eval { System::Command->new(qw( gpg --version ))->stdout->getline }
    or die "gpg not found in the path\n";

# setup our local GnuPG environment
$ENV{GNUPGHOME} = File::Spec->catfile( getcwd(), 'gnupg' );
my $keyid = '7621C403';

# setup a test repository
my $r = test_repository( git => { quiet => 1 } );

# some settings
$ENV{GIT_AUTHOR_DATE}  = my $tick = time - 3600;
$ENV{GIT_AUTHOR_NAME}  = $ENV{GIT_COMMITTER_NAME}  = 'Example Author';
$ENV{GIT_AUTHOR_EMAIL} = $ENV{GIT_COMMITTER_EMAIL} = 'author@example.com';

### helper subs

# put content in a file, with an optional encoding
my $file = File::Spec->catfile( $r->work_tree => 'file.txt' );
sub update_file {
    my ( $content, $encoding ) = @_;
    $encoding ||= 'UTF-8';
    open my $fh, ">:encoding($encoding)", $file or die "Can't open $file: $!";
    print {$fh} $content;
    close $fh;
    $r->run( add => $file );
}

# enable the verbose option
my %seen;
sub commit {
    my %arg = @_;

    # update the file if needed
    if ( $arg{content} ) {
        update_file( $arg{content}, $arg{content_encoding} );
    }

    # click a tick
    $tick++;
    $ENV{GIT_AUTHOR_DATE} = "$tick +0200";

    # execute the coderef
    $r->run( config => 'i18n.commitencoding', $arg{commit_encoding} )
        if $arg{commit_encoding};
    $arg{code}->();
    $r->run( config => qw( --unset i18n.commitencoding iso-8859-1 ) )
        if $arg{commit_encoding};

    # show the raw commit for --verbose
    my $head = $r->run( log => -1 => '--pretty=format:%H' );
    return if $seen{$head}++;
    return if !$option{verbose};
    print "---- $head ", '-' x 32, "\n";
    print "$_\n" for $r->run( qw( cat-file commit ), $head );
    print "\n";
}


### main program

# empty tree
commit(
    code => sub {
        my $tree = $r->run( mktree => { input => '' } );
        my $head = $r->run( 'commit-tree', $tree, -m => 'empty tree' );
        $r->run( 'update-ref', 'refs/heads/master' => $head );
    }
);

# simple commit
commit(
    content => "Hello\n",
    code    => sub {
        $r->run( commit => -m => 'hello (en)' );
    }
);

# make an encoding branch
$r->run( branch => 'encoding' );

# commit with utf8 blob and message
commit(
    content => "こんにちは\n",
    code    => sub { $r->run( commit => -am => 'こんにちは (ja)' ); },
);

# gpgsig
commit(
    content => "hej\n",
    code    => sub {
        $r->run( commit => "-S$keyid" => -m => 'hej (da)' );
    }
);

# encoding shift-jis
$r->run( checkout => 'encoding' );
commit(
    content  => "こんにちは\n",
    content_encoding => 'shift-jis',
    commit_encoding => 'shift-jis',
    code     => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'shift-jis', 'こんにちは (ja)' );
        $cmd->close;
    }
);

# encoding iso-8859-1
commit(
    content => "halló\n", # utf-8
    commit_encoding => 'iso-8859-1',
    code    => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'halló (is)' );
        $cmd->close;
    }
);

# signed tag
commit(    # actually, no commit
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.0' );
    }
);

# encoding
commit(
    content => "góður dagur\n", # utf-8
    commit_encoding => 'iso-8859-1',
    code    => sub {
        my $cmd = $r->command( commit => '-aF-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'góður dagur (is)' );
        $cmd->close;
    }
);

# signed tag
commit(    # actually, no commit
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.1' );
    }
);

# gpgsig + encoding
commit(
    content  => 'olá',
    content_encoding => 'iso-8859-1',
    commit_encoding => 'iso-8859-1',
    code     => sub {
        my $cmd = $r->command( commit => '-aF-' => "-S$keyid" );
        print { $cmd->stdin } encode( 'iso-8859-1', 'olá (pt)' );
        $cmd->close;
    }
);


# signed tag
commit( # no commit
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.2' );
    }
);

# some basic commit
commit(
    content => "bonjour\n",
    code    => sub {
        $r->run( commit => -m => 'bonjour (fr)' );
    }
);

# signed tag
commit(
    code => sub {
        $r->run( tag => -m => 'signed tag', -u => $keyid, -s => 'v1.0.3' );
    }
);

# mergetag
$r->run( checkout => 'master' );
commit( code => sub { $r->run( merge => -s => 'ours', 'v1.0.0' ); } );

# mergetag + encoding
commit(
    commit_encoding => 'iso-8859-1',
    code            => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.1' );
        my $cmd = $r->command( commit => '-F-' );
        print { $cmd->stdin } encode( 'iso-8859-1', 'dobrý den (cs)' );
        $cmd->close;
    }
);

# mergetag + gpgsig
commit(
    code => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.2' );
        $r->run( commit => -am => 'bom dia', "-S$keyid" );
    }
);

# mergetag + gpgsig + encoding
commit(
    commit_encoding => 'iso-8859-1',
    code            => sub {
        $r->run( merge => -s => 'ours', '--no-commit', 'v1.0.3' );
        my $cmd = $r->command( commit => '-aF-' => "-S$keyid" );
        print { $cmd->stdin } encode( 'iso-8859-1', 'buen día (es)' );
        $cmd->close;
    }
);

### final steps

# gitk
if( $option{gitk} ) {
    my $home = getcwd();
    chdir $r->work_tree;
    `gitk --all --date-order`;
    chdir $home;
}

# bundle
if( !-e $option{bundle} || $option{force} ) {
    $r->run( bundle => create => $option{bundle} => '--all' );
}
